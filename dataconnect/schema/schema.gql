# Example schema for simple movie review app

# User table is keyed by Firebase Auth UID.
type User @table {
  # `@default(expr: "auth.uid")` sets it to Firebase Auth UID during insert and upsert.
  id: String! @default(expr: "auth.uid")
  username: String! @col(dataType: "varchar(50)")
  # The `user: User!` field in the Review table generates the following one-to-many query field.
  #  reviews_on_user: [Review!]!
  # The `Review` join table the following many-to-many query field.
  #  movies_via_Review: [Movie!]!
}

# Movie is keyed by a randomly generated UUID.
type Movie @table {
  # If you do not pass a 'key' to `@table`, Data Connect automatically adds the following 'id' column.
  # Feel free to uncomment and customize it.
  #  id: UUID! @default(expr: "uuidV4()")
  title: String!
  imageUrl: String!
  genre: String
}

# MovieMetadata is a metadata attached to a Movie.
# Movie <-> MovieMetadata is a one-to-one relationship
type MovieMetadata @table {
  # @unique ensures each Movie can only one MovieMetadata.
  movie: Movie! @unique
  # The movie field adds the following foreign key field. Feel free to uncomment and customize it.
  #  movieId: UUID!
  rating: Float
  releaseYear: Int
  description: String
}

# Reviews is a join table between User and Movie.
# It has a composite primary keys `userUid` and `movieId`.
# A user can leave reviews for many movies. A movie can have reviews from many users.
# User  <-> Review is a one-to-many relationship
# Movie <-> Review is a one-to-many relationship
# Movie <-> User is a many-to-many relationship
type Review @table(name: "Reviews", key: ["movie", "user"]) {
  user: User!
  # The user field adds the following foreign key field. Feel free to uncomment and customize it.
  #  userUid: String!
  movie: Movie!
  # The movie field adds the following foreign key field. Feel free to uncomment and customize it.
  #  movieId: UUID!
  rating: Int
  reviewText: String
  reviewDate: Date! @default(expr: "request.time")
}

# Blog Automation System Schema

# TopicalMap defines content topics across Audio Jones' 5 strategic pillars
type TopicalMap @table {
  id: UUID! @default(expr: "uuidV4()")
  pillar: String! @col(dataType: "varchar(50)") # ai, marketing, podcast-news, tech-business-trends, personal-brand
  topic: String! @col(dataType: "varchar(255)")
  persona: String! @col(dataType: "varchar(50)") # creator, entrepreneur, smb, agency
  intent: String! @col(dataType: "varchar(100)")
  sourceUrls: [String!]! @col(dataType: "text[]")
  priority: Int! @default(expr: "1")
  lastGenerated: Timestamp
  active: Boolean! @default(expr: "true")
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# BlogDraft stores all blog content drafts with metadata
type BlogDraft @table {
  id: UUID! @default(expr: "uuidV4()")
  pillar: String! @col(dataType: "varchar(50)")
  source: String! @col(dataType: "varchar(50)") # perplexity, internal, mixed
  status: String! @col(dataType: "varchar(50)") @default(expr: "'draft'") # draft, needs_review, approved, scheduled, published, optimization_pending
  title: String! @col(dataType: "varchar(500)")
  slug: String! @unique @col(dataType: "varchar(255)")
  content: String! @col(dataType: "text") # Markdown content
  seoTitle: String @col(dataType: "varchar(255)")
  seoDescription: String @col(dataType: "varchar(500)")
  seoKeywords: [String!]! @col(dataType: "text[]")
  ogImage: String @col(dataType: "varchar(500)")
  faqs: String @col(dataType: "text") # JSON array of FAQ objects
  keyTakeaways: [String!]! @col(dataType: "text[]")
  structuredData: String @col(dataType: "text") # JSON structured data
  ctaType: String! @col(dataType: "varchar(50)") # newsletter, podcast, services, lead_magnet
  ctaHeadline: String! @col(dataType: "varchar(255)")
  ctaDescription: String! @col(dataType: "varchar(500)")
  ctaLink: String! @col(dataType: "varchar(500)")
  researchPayload: String @col(dataType: "text") # Original Perplexity JSON
  frameworkUsed: String @col(dataType: "varchar(10)") # EPM, ASI, PR, AOF
  readingTime: Int @default(expr: "5") # Estimated reading time in minutes
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
  scheduledFor: Timestamp
  publishedAt: Timestamp
}

# BlogVariant stores A/B test variants for blog content
type BlogVariant @table {
  id: UUID! @default(expr: "uuidV4()")
  draft: BlogDraft!
  variantType: String! @col(dataType: "varchar(50)") # title, intro, cta, hero_media
  originalValue: String! @col(dataType: "text")
  variantValue: String! @col(dataType: "text")
  testPercentage: Int! @default(expr: "50") # Percentage of traffic to serve this variant
  performanceData: String @col(dataType: "text") # JSON performance metrics
  active: Boolean! @default(expr: "true")
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ContentPerformance tracks blog post analytics and engagement
type ContentPerformance @table {
  id: UUID! @default(expr: "uuidV4()")
  draft: BlogDraft! @unique
  slug: String! @col(dataType: "varchar(255)")
  pillar: String! @col(dataType: "varchar(50)")
  views: Int! @default(expr: "0")
  engagementTime: Int! @default(expr: "0") # Average time in seconds
  conversions: Int! @default(expr: "0")
  socialShares: Int! @default(expr: "0")
  searchImpressions: Int! @default(expr: "0")
  bounceRate: Float! @default(expr: "0.0")
  performanceScore: Float! @default(expr: "0.0") # Calculated score 0-1
  lastUpdated: Timestamp! @default(expr: "request.time")
}

# ContentSchedule manages publishing schedule and distribution
type ContentSchedule @table {
  id: UUID! @default(expr: "uuidV4()")
  draft: BlogDraft!
  scheduledFor: Timestamp!
  status: String! @col(dataType: "varchar(50)") @default(expr: "'pending'") # pending, published, failed
  distributionChannels: [String!]! @col(dataType: "text[]") # newsletter, social, rss
  retryCount: Int! @default(expr: "0")
  lastAttempt: Timestamp
  errorMessage: String @col(dataType: "text")
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}
